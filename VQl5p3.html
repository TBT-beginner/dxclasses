<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 5-3 助動詞 ③ 全問題演習</title>
    <style>
        body {
            font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 20px auto;
            padding: 0 20px;
            background-color: #f4f4f9;
        }
        h1, h2 {
            border-bottom: 2px solid #4a90e2;
            padding-bottom: 10px;
            color: #4a90e2;
        }
        .quiz-container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .question-block {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px dashed #ccc;
        }
        .question-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .question-text {
            margin-bottom: 10px;
        }
        .options { margin-bottom: 10px; }
        .radio-option {
            display: block;
            margin-bottom: 8px;
            cursor: pointer;
        }
        .radio-option input {
            margin-right: 8px;
        }
        input[type="text"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            margin-right: 5px;
        }
        .reorder-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            min-height: 40px;
            margin-bottom: 10px;
        }
        .reorder-word {
            padding: 5px 10px;
            background-color: #4a90e2;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }
        button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            margin-right: 5px;
            margin-top: 5px;
            transition: background-color 0.2s;
        }
        .btn-check { background-color: #337ab7; }
        .btn-check:hover { background-color: #286090; }
        .btn-hint { background-color: #f0ad4e; }
        .btn-hint:hover { background-color: #ec971f; }
        .btn-trans { background-color: #5bc0de; }
        .btn-trans:hover { background-color: #46b8da; }
        .btn-vocab { background-color: #9c27b0; }
        .btn-vocab:hover { background-color: #7b1fa2; }
        .btn-reset { background-color: #777; }
        .btn-reset:hover { background-color: #666; }
        .hidden-content {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .result {
            margin-top: 10px;
            font-weight: bold;
        }
        .correct { color: green; }
        .incorrect { color: red; }
        .explanation {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff8e1;
            border: 1px solid #ffecb3;
            border-radius: 4px;
            font-weight: normal;
        }
        #submit-all {
            display: block;
            width: 100%;
            padding: 15px;
            font-size: 18px;
            background-color: #d9534f;
        }
        #submit-all:hover {
            background-color: #c9302c;
        }
    </style>
</head>
<body>

    <h1>Lesson 5-3 助動詞 ③ 全問題演習</h1>
    <div id="quiz-app"></div>
    <button id="submit-all">まとめて採点！</button>

    <script>
        const quizData = [
            {
                section: "Exercises 1 - １ 選択問題",
                questions: [
                    {
                        id: 'ex1_1_1', type: 'select',
                        text: '1. Sally looks sleepy. She (___) up late last night.',
                        options: ['must stay', 'must have stayed'],
                        answer: 'must have stayed',
                        translation: 'サリーは眠そうだ。彼女は昨夜、夜更かししたに違いない。',
                        hint: '`last night` とあるので過去の出来事です。「強い確信（〜に違いない）」と「過去」を表す表現を選びましょう。',
                        explanation: '`last night`（昨夜）のことなので、過去の出来事についての推量です。過去の「強い確信・推量（〜したに違いない）」は **<must + have + 過去分詞>** の形を使います。したがって、`must have stayed` が正解です。<br><b>動詞の活用:</b> `stay` は `stay-stayed-stayed` と変化する規則変化動詞です。',
                        vocab: { 'stay up late': '夜更かしする' }
                    },
                    {
                        id: 'ex1_1_2', type: 'select',
                        text: '2. It’s April now. It (___) in Kyushu.',
                        options: ['can’t have snowed', 'should have snowed'],
                        answer: 'can’t have snowed',
                        translation: '今は4月だ。九州で雪が降ったはずがない。',
                        hint: '4月の九州で雪が降ることは考えにくい状況です。「〜なはずがない」という過去への強い否定を表す表現を使いましょう。',
                        explanation: '「4月の九州で雪」という状況から、過去の出来事に対する「強い否定（〜したはずがない）」を表す必要があります。この意味を表すのは **<can’t + have + 過去分詞>** です。したがって、`can’t have snowed` が正解です。<br><b>動詞の活用:</b> `snow` は `snow-snowed-snowed` と変化する規則変化動詞です。',
                    },
                    {
                        id: 'ex1_1_3', type: 'select',
                        text: '3. I failed the test. I (___) harder for the next one.',
                        options: ['should study', 'should have studied'],
                        answer: 'should study',
                        translation: 'テストに落ちた。次のテストに向けてもっと一生懸命勉強すべきだ。',
                        hint: '`for the next one`（次のテスト）について述べているので、未来への行動についてです。「〜すべきだ」という現在の義務・助言を表す `should` を選びます。',
                        explanation: '`for the next one`（次のために）と未来に向けた話をしているので、過去の後悔ではありません。「（これから）〜すべきだ」という助言や義務を表す **<should + 動詞の原形>** を使います。`should have studied` は「勉強すべきだったのに（しなかった）」という過去への後悔を表すので、文脈に合いません。',
                        vocab: { 'fail the test': 'テストに落ちる' }
                    },
                    {
                        id: 'ex1_1_4', type: 'select',
                        text: '4. You really enjoyed the camp. I (___) with you.',
                        options: ['should go', 'should have gone'],
                        answer: 'should have gone',
                        translation: 'あなたは本当にキャンプを楽しんだね。私も一緒に行くべきだったのに。',
                        hint: '行動しなかったことへの「後悔」の気持ちを表しています。「〜すべきだったのに（しなかった）」という意味の表現を選びましょう。',
                        explanation: '一緒に行かなかったことを後悔している文脈です。過去の行動に対する「後悔（〜すべきだったのに）」は **<should + have + 過去分詞>** で表します。したがって、`should have gone` が正解です。<br><b>動詞の活用:</b> `go` は `go-went-gone` と変化する不規則変化動詞です。',
                    },
                    {
                        id: 'ex1_1_5', type: 'select',
                        text: '5. It was sunny. You (___) your umbrella.',
                        options: ['needn’t take', 'needn’t have taken'],
                        answer: 'needn’t have taken',
                        translation: '晴れていたよ。傘を持ってくる必要はなかったのに。',
                        hint: '実際には傘を持ってきた状況です。「〜する必要はなかったのに（してしまった）」という意味の表現を選びましょう。',
                        explanation: '「晴れていた」`It was sunny.` とあるので、過去の不要な行動について述べています。「〜する必要はなかったのに（実際にはしてしまった）」という意味は **<needn’t + have + 過去分詞>** で表します。`needn’t have taken` が正解です。<br><b>動詞の活用:</b> `take` は `take-took-taken` と変化する不規則変化動詞です。'
                    }
                ]
            },
            {
                section: "Exercises 1 - ２ 穴埋め問題",
                questions: [
                    { id: 'ex1_2_1', type: 'fill', text: '1. I ___ a new smartphone. <br>[ 選択肢: would like / would like to / would rather ]', answer: 'would like', translation: '新しいスマートフォンが欲しいのですが。', hint: '`want` の丁寧な表現です。後ろには `a new smartphone` という名詞が続いています。', explanation: '後ろに `a new smartphone` という名詞が続いているので、「〜が欲しいのですが」という意味の **would like** が適切です。`would like to` の後には動詞の原形が、`would rather` の後にも動詞の原形が続きます。'},
                    { id: 'ex1_2_2', type: 'fill', text: '2. Although I asked him to continue his job, he ___ quit it. <br>[ 選択肢: would like / would like to / would rather ]', answer: 'would rather', translation: '私は彼に仕事を続けるよう頼んだけれども、彼はむしろ辞めたがっている。', hint: '2つの選択肢を比較して「むしろ〜したい」という願望を表す表現を使います。', explanation: '仕事を「続ける」ことと「辞める」ことを比較し、「むしろ〜したい」という願望を表しています。この意味を持つのは **would rather** です。', vocab: { 'continue': '続ける', 'quit': 'やめる' }},
                    { id: 'ex1_2_3', type: 'fill', text: '3. I ___ take a walk than go straight home. <br>[ 選択肢: would like / would like to / would rather ]', answer: 'would rather', translation: 'まっすぐ家に帰るよりむしろ散歩したい。', hint: '文中に `than` があります。「〜するより、むしろ…したい」を表す構文を選びましょう。', explanation: '文中に `than` があり、2つの行動を比較しています。「AするよりむしろBしたい」は **<would rather B than A>** の構文を使います。したがって、`would rather` が正解です。', vocab: { 'take a walk': '散歩する', 'go straight home': 'まっすぐ家に帰る' }},
                    { id: 'ex1_2_4', type: 'fill', text: '4. I ___ try on these jeans. <br>[ 選択肢: would like / would like to / would rather ]', answer: 'would like to', translation: 'このジーンズを試着したいのですが。', hint: '`want to do` の丁寧な表現です。後ろには `try on` という動詞の原形が続いています。', explanation: '後ろに `try on` という動詞の原形が続いているので、「〜したいのですが」という意味の **would like to** が適切です。`would like` の後には名詞が続きます。', vocab: { 'try on': '〜を試着する' }}
                ]
            },
            {
                section: "Exercises 1 - ３ 英文完成問題",
                questions: [
                    { id: 'ex1_3_1', type: 'fill', text: '1. 彼はひどい風邪を引いたに違いない。<br>He ___ a terrible cold. [ catch ]', answer: 'must have caught', hint: '「〜したに違いない」という過去への「強い確信」を表します。`must have` の後に `catch` の過去分詞形を使います。', explanation: '「〜したに違いない」という過去への強い確信は **<must have + 過去分詞>** で表します。<br><b>動詞の活用:</b> `catch` は `catch-caught-caught` と変化する不規則変化動詞です。', vocab: { 'catch a cold': '風邪をひく' }},
                    { id: 'ex1_3_2', type: 'fill', text: '2. 彼らはうそをつく必要はなかったのに。<br>They ___ because he knew the truth. [ lie ]', answer: 'needn’t have lied', hint: '「〜する必要はなかったのに（してしまった）」という意味です。`needn’t have` の後に `lie` の過去分詞形を続けましょう。', explanation: '「〜する必要はなかったのに（実際にはしてしまった）」は **<needn’t have + 過去分詞>** で表します。<br><b>動詞の活用:</b> `lie` (うそをつく) は `lie-lied-lied` と変化する規則変化動詞です。', vocab: { 'truth': '真実' }},
                    { id: 'ex1_3_3', type: 'fill', text: '3. 彼らはひどい雨の中で試合をしたはずがない。<br>They ___ a game in the heavy rain. [ play ]', answer: 'can’t have played', hint: '「〜したはずがない」という過去への「強い否定」を表します。`can’t have` の後に `play` の過去分詞形を使います。', explanation: '「〜したはずがない」という過去への強い否定は **<can’t have + 過去分詞>** で表します。<br><b>動詞の活用:</b> `play` は `play-played-played` と変化する規則変化動詞です。'},
                    { id: 'ex1_3_4', type: 'fill', text: '4. あなたはパーティーで私の友人の１人に会ったかもしれない。<br>You ___ one of my friends at the party. [ meet ]', answer: ['may have met', 'might have met'], hint: '「〜したかもしれない」という過去への「推量」を表します。`may have` の後に `meet` の過去分詞形を使いましょう。', explanation: '「〜したかもしれない」という過去への推量は **<may/might have + 過去分詞>** で表します。`might` を使うと確信度がより低くなります。<br><b>動詞の活用:</b> `meet` は `meet-met-met` と変化する不規則変化動詞です。'},
                    { id: 'ex1_3_5', type: 'fill', text: '5. 私たちはもっと早くその問題と向き合うべきだったのに。<br>We ___ the problem earlier. [ face ]', answer: 'should have faced', hint: '「〜すべきだったのに（しなかった）」という過去への「後悔」を表します。`should have` の後に `face` の過去分詞形を使います。', explanation: '「〜すべきだったのに（しなかった）」という過去への後悔は **<should have + 過去分詞>** で表します。<br><b>動詞の活用:</b> `face` は `face-faced-faced` と変化する規則変化動詞です。', vocab: { 'face the problem': '問題に直面する、向き合う' }},
                    { id: 'ex1_3_6', type: 'fill', text: '6. 父はその会議に出席したはずだ。<br>My father ___ the meeting. [ attend ]', answer: 'should have attended', hint: 'ここでは後悔ではなく、「〜したはずだ」という過去への「推量」を表します。`should have` を使いましょう。', explanation: '「〜したはずだ」という過去への推量（当然そうしているはずだという期待）は **<should have + 過去分詞>** で表します。<br><b>動詞の活用:</b> `attend` は `attend-attended-attended` と変化する規則変化動詞です。', vocab: { 'attend the meeting': '会議に出席する' }},
                    { id: 'ex1_3_7', type: 'fill', text: '7. ひょっとするとその電車は時間どおりに到着しなかったのかもしれない。<br>The train ___ on time. [ arrive ]', answer: 'might not have arrived', hint: '「ひょっとすると〜しなかったかもしれない」という、確信度の低い過去への否定的な推量を表します。', explanation: '「〜しなかったかもしれない」という確信度の低い過去への否定的な推量は **<might not have + 過去分詞>** で表します。<br><b>動詞の活用:</b> `arrive` は `arrive-arrived-arrived` と変化する規則変化動詞です。', vocab: { 'on time': '時間どおりに' }}
                ]
            },
            {
                section: "Exercises 2 - ４ 状況描写問題",
                questions: [
                    { id: 'ex2_4_1', type: 'fill', text: '1. (シャワーよりお風呂に入りたい状況)<br>I ___ a bath.', answer: 'would rather take', hint: '2つの選択肢を比較し、「むしろ〜したい」と願望を述べる表現です。`would rather` の後には動詞の原形が来ます。', explanation: '選択肢の中から「むしろ〜したい」という願望を表すのは **<would rather + 動詞の原形>** です。`take a bath` で「お風呂に入る」という意味になります。', vocab: { 'take a bath': 'お風呂に入る' }},
                    { id: 'ex2_4_2', type: 'fill', text: '2. (相手に飲み物を勧めている状況)<br>___ something to drink?', answer: 'Would you like', hint: '相手に丁寧に何かを勧める際の決まった表現です。「〜はいかがですか？」と尋ねます。', explanation: '相手に丁寧に何かを勧める際の決まり文句は **Would you like...?** です。'},
                    { id: 'ex2_4_3', type: 'fill', text: '3. No one answered. They ___ out.', answer: 'must have gone', hint: '誰も電話に出なかった理由を強く推測しています。「〜したに違いない」という過去への確信を表す `must have` を使いましょう。', explanation: '電話に出なかった理由について、「外出したに違いない」という過去への強い推量をしています。これは **<must have + 過去分詞>** で表します。<br><b>動詞の活用:</b> `go` は `go-went-gone` と変化する不規則変化動詞です。', vocab: { 'go out': '外出する' }}
                ]
            },
            {
                section: "Exercises 2 - ５ 語順整序問題",
                questions: [
                    { id: 'ex2_5_1', type: 'reorder', text: '1. 彼は突然の雨でぬれてしまったに違いない。<br>He ( in / have / got / must / wet ) the sudden rain.', options: ['in', 'have', 'got', 'must', 'wet'], answer: 'must have got wet in', hint: 'まず「〜に違いない」という `He must have` から文を組み立てます。その後に「ぬれた」という意味の `got wet` を続けます。', explanation: '「〜に違いない」という過去への強い推量は **<must have + 過去分詞>** で表します。まず `must have` を置きます。次に「ぬれる」という熟語 `get wet` の過去分詞形 `got wet` を続けます。最後に場所を示す `in` が来ます。正しい語順は `must have got wet in` となります。<br><b>動詞の活用:</b> `get` は `get-got-got(ten)` と変化する不規則変化動詞です。', vocab: { 'get wet': 'ぬれる' }},
                    { id: 'ex2_5_2', type: 'reorder', text: '2. その本は売り切れていた。最初にお店に電話すればよかった。<br>The book was sold out. ( called / have / should / the store / I ) first.', options: ['called', 'have', 'should', 'the store', 'I'], answer: 'I should have called the store', hint: '「電話すればよかった」という「後悔」の文です。「私は〜すべきだった」という意味の `I should have` から始めましょう。', explanation: '「〜すればよかった」という過去への後悔は **<主語 + should have + 過去分詞>** で表します。主語 `I` から始め、`should have`、動詞の過去分詞 `called`、目的語 `the store` と続けます。正しい語順は `I should have called the store` となります。<br><b>動詞の活用:</b> `call` は `call-called-called` と変化する規則変化動詞です。', vocab: { 'be sold out': '売り切れている' }},
                    { id: 'ex2_5_3', type: 'reorder', text: '3. 夕食を作るよりもむしろ外食したい。<br>I ( cook / eat out / rather / than / would ) dinner.', options: ['cook', 'eat out', 'rather', 'than', 'would'], answer: 'would rather eat out than cook', hint: '「〜するよりもむしろ…したい」は `would rather ... than 〜` の語順になります。`eat out` と `cook` を正しい位置に入れましょう。', explanation: '「〜するよりもむしろ…したい」は **<would rather + 動詞A + than + 動詞B>** という構文を使います。ここでは「外食したい」が動詞A (`eat out`)、「夕食を作る」が動詞B (`cook`) にあたります。したがって、`would rather eat out than cook` が正しい語順です。', vocab: { 'eat out': '外食する' }}
                ]
            },
            {
                section: "Exercises 2 - ６ 英文完成問題",
                questions: [
                    { id: 'ex2_6_1', type: 'fill', text: '1. Ken seems angry with Emily. ___ her promise.', answer: 'She may have broken', translation: 'ケンはエミリーに怒っているようだ。彼女が約束を破ったのかもしれない。', hint: '「〜したのかもしれない」という過去への「推量」を表します。`may have` の後に `break one\'s promise` を続けましょう。', explanation: '「〜したのかもしれない」という過去への推量は **<may have + 過去分詞>** で表します。主語が `She` なので `She may have broken` となります。<br><b>動詞の活用:</b> `break` は `break-broke-broken` と変化する不規則変化動詞です。', vocab: { "break one's promise": '約束を破る' }},
                    { id: 'ex2_6_2', type: 'fill', text: '2. ___ a new business.', answer: 'She can’t have started', translation: '彼女が新しい事業を始めたはずがない。', hint: '「〜したはずがない」という過去への「強い否定」を表します。`can’t have` の後に `start a business` を続けましょう。', explanation: '「〜したはずがない」という過去への強い否定は **<主語 + can’t have + 過去分詞>** で表します。主語を補うと `She can’t have started` となります。<br><b>動詞の活用:</b> `start` は `start-started-started` と変化する規則変化動詞です。', vocab: { 'start a business': '事業を始める' }}
                ]
            }
        ];

        const app = document.getElementById('quiz-app');

        function renderQuiz() {
            quizData.forEach(sectionData => {
                const sectionEl = document.createElement('div');
                sectionEl.className = 'quiz-container';
                
                const sectionTitle = document.createElement('h2');
                sectionTitle.textContent = sectionData.section;
                sectionEl.appendChild(sectionTitle);

                sectionData.questions.forEach((q, index) => {
                    const block = document.createElement('div');
                    block.className = 'question-block';
                    block.id = `block-${q.id}`;

                    const title = document.createElement('div');
                    title.className = 'question-title';
                    
                    const questionText = document.createElement('p');
                    questionText.className = 'question-text';
                    questionText.innerHTML = q.text;
                    title.appendChild(questionText);
                    
                    block.appendChild(title);
                    
                    const controls = document.createElement('div');
                    controls.className = 'options';

                    if (q.type === 'select') {
                        q.options.forEach((opt, optIndex) => {
                            const label = document.createElement('label');
                            label.className = 'radio-option';
                            
                            const radio = document.createElement('input');
                            radio.type = 'radio';
                            radio.name = `q-${q.id}`;
                            radio.value = opt;
                            radio.id = `q-${q.id}-${optIndex}`;

                            label.appendChild(radio);
                            label.appendChild(document.createTextNode(` ${opt}`));
                            controls.appendChild(label);
                        });
                    } else if (q.type === 'fill') {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.id = `q-${q.id}`;
                        input.placeholder = '答えを入力';
                        controls.appendChild(input);
                    } else if (q.type === 'reorder') {
                        const answerArea = document.createElement('div');
                        answerArea.className = 'reorder-area';
                        answerArea.id = `answer-${q.id}`;
                        
                        const optionsArea = document.createElement('div');
                        optionsArea.className = 'reorder-area';
                        optionsArea.id = `options-${q.id}`;

                        q.options.forEach(opt => {
                            const word = document.createElement('span');
                            word.className = 'reorder-word';
                            word.textContent = opt;
                            word.onclick = () => moveWord(word, q.id);
                            optionsArea.appendChild(word);
                        });
                        
                        const resetButton = document.createElement('button');
                        resetButton.textContent = 'リセット';
                        resetButton.className = 'btn-reset';
                        resetButton.onclick = () => resetReorder(q.id);

                        controls.appendChild(document.createTextNode('解答欄:'));
                        controls.appendChild(answerArea);
                        controls.appendChild(document.createTextNode('選択肢:'));
                        controls.appendChild(optionsArea);
                        controls.appendChild(resetButton);
                    }
                    
                    block.appendChild(controls);

                    const checkButton = document.createElement('button');
                    checkButton.textContent = 'この問題を採点';
                    checkButton.className = 'btn-check';
                    checkButton.onclick = () => checkSingleAnswer(q.id);
                    block.appendChild(checkButton);

                    const hintButton = document.createElement('button');
                    hintButton.textContent = 'ヒントを見る';
                    hintButton.className = 'btn-hint';
                    hintButton.onclick = () => toggleVisibility(`hint-${q.id}`);
                    block.appendChild(hintButton);

                    if(q.translation) {
                        const transButton = document.createElement('button');
                        transButton.textContent = '日本語訳を見る';
                        transButton.className = 'btn-trans';
                        transButton.onclick = () => toggleVisibility(`trans-${q.id}`);
                        block.appendChild(transButton);
                    }

                    if (q.vocab) {
                        const vocabButton = document.createElement('button');
                        vocabButton.textContent = '語彙を見る';
                        vocabButton.className = 'btn-vocab';
                        vocabButton.onclick = () => toggleVisibility(`vocab-${q.id}`);
                        block.appendChild(vocabButton);
                    }

                    const hintContent = document.createElement('div');
                    hintContent.id = `hint-${q.id}`;
                    hintContent.className = 'hidden-content';
                    hintContent.innerHTML = q.hint;
                    block.appendChild(hintContent);
                    
                    if(q.translation) {
                        const transContent = document.createElement('div');
                        transContent.id = `trans-${q.id}`;
                        transContent.className = 'hidden-content';
                        transContent.innerHTML = q.translation;
                        block.appendChild(transContent);
                    }
                    
                    if (q.vocab) {
                        const vocabContent = document.createElement('div');
                        vocabContent.id = `vocab-${q.id}`;
                        vocabContent.className = 'hidden-content';
                        let vocabHTML = '';
                        for (const [key, value] of Object.entries(q.vocab)) {
                            vocabHTML += `<b>${key}</b>: ${value}<br>`;
                        }
                        vocabContent.innerHTML = vocabHTML;
                        block.appendChild(vocabContent);
                    }

                    const resultEl = document.createElement('div');
                    resultEl.id = `result-${q.id}`;
                    resultEl.className = 'result';
                    block.appendChild(resultEl);

                    sectionEl.appendChild(block);
                });
                app.appendChild(sectionEl);
            });
        }

        function toggleVisibility(id) {
            const el = document.getElementById(id);
            el.style.display = el.style.display === 'block' ? 'none' : 'block';
        }
        
        function moveWord(wordEl, qId) {
            const answerArea = document.getElementById(`answer-${qId}`);
            const optionsArea = document.getElementById(`options-${qId}`);
            if (wordEl.parentElement.id.startsWith('options')) {
                answerArea.appendChild(wordEl);
            } else {
                optionsArea.appendChild(wordEl);
            }
        }
        
        function resetReorder(qId) {
            const answerArea = document.getElementById(`answer-${qId}`);
            const optionsArea = document.getElementById(`options-${qId}`);
            while (answerArea.firstChild) {
                optionsArea.appendChild(answerArea.firstChild);
            }
        }

        function checkSingleAnswer(qId) {
            let questionData = null;
            for (const section of quizData) {
                const found = section.questions.find(q => q.id === qId);
                if (found) { questionData = found; break; }
            }
            if (!questionData) return;
            
            let userAnswer;
            const q = questionData;
            const resultEl = document.getElementById(`result-${q.id}`);
            resultEl.innerHTML = '';

            if (q.type === 'select') {
                const checkedRadio = document.querySelector(`input[name="q-${q.id}"]:checked`);
                userAnswer = checkedRadio ? checkedRadio.value : '';
            } else if (q.type === 'fill') {
                userAnswer = document.getElementById(`q-${q.id}`).value.trim();
            } else if (q.type === 'reorder') {
                const answerWords = Array.from(document.getElementById(`answer-${q.id}`).children);
                userAnswer = answerWords.map(w => w.textContent).join(' ');
            }

            let isCorrect = false;
            if (Array.isArray(q.answer)) {
                // 解答が複数ある場合（小文字大文字を無視して比較）
                isCorrect = q.answer.some(ans => ans.toLowerCase() === userAnswer.toLowerCase());
            } else {
                // 解答が単一の場合（小文字大文字を無視して比較）
                isCorrect = userAnswer.toLowerCase() === q.answer.toLowerCase();
            }

            if (isCorrect) {
                resultEl.textContent = '正解！';
                resultEl.className = 'result correct';
            } else {
                const resultText = document.createElement('span');
                resultText.textContent = '不正解...';
                
                const explanation = document.createElement('div');
                explanation.className = 'explanation';
                const correctAnswerText = Array.isArray(q.answer) ? q.answer.join(' または ') : q.answer;
                explanation.innerHTML = q.explanation + `<br><b>正解:</b> ${correctAnswerText}`;
                
                resultEl.appendChild(resultText);
                resultEl.appendChild(explanation);
                resultEl.className = 'result incorrect';
            }
        }

        function checkAllAnswers() {
            quizData.forEach(sectionData => {
                sectionData.questions.forEach(q => {
                    checkSingleAnswer(q.id);
                });
            });
        }

        document.addEventListener('DOMContentLoaded', renderQuiz);
        document.getElementById('submit-all').addEventListener('click', checkAllAnswers);
    </script>
</body>
</html>
